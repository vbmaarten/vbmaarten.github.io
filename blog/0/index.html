<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/f686a73ef698d4bc-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/409d8ae84a415574.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-50947f5c0ca940e8.js"/><script src="/_next/static/chunks/4bd1b696-20882bf820444624.js" async=""></script><script src="/_next/static/chunks/517-4f92d65354372eef.js" async=""></script><script src="/_next/static/chunks/main-app-1bfcab0873ab94e3.js" async=""></script><script src="/_next/static/chunks/970-c92a9d6897ab6f71.js" async=""></script><script src="/_next/static/chunks/173-0c26dd97dcd696c8.js" async=""></script><script src="/_next/static/chunks/app/blog/page-e0864ade7711998e.js" async=""></script><script src="/_next/static/chunks/app/layout-bbbc5ec467b780d9.js" async=""></script><script src="/_next/static/chunks/app/blog/%5Bslug%5D/page-3b3d82faeb35df04.js" async=""></script><link rel="preload" href="/hljs/highlight.min.js" as="script"/><link rel="preload" href="/hljs/glsl.min.js" as="script"/><meta name="next-size-adjust" content=""/><title>Maarten van Beek</title><meta property="og:title" content="Maarten van Beek"/><meta property="og:description" content="Software developer"/><meta property="og:site_name" content="Maarten van Beek"/><meta property="og:image" content="https://www.maartenvb.org/cactus_flower_logo.png"/><meta property="og:image:secure_url" content="http://www.maartenvb.org/cactus_flower_logo.png"/><meta property="og:image:width" content="1600"/><meta property="og:image:height" content="900"/><meta property="og:image:alt" content="cactus flower logo"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="Maarten van Beek"/><meta name="twitter:description" content="Software developer"/><meta name="twitter:image" content="https://www.maartenvb.org/cactus_flower_logo.png"/><meta name="twitter:image:secure_url" content="http://www.maartenvb.org/cactus_flower_logo.png"/><meta name="twitter:image:width" content="1600"/><meta name="twitter:image:height" content="900"/><meta name="twitter:image:alt" content="cactus flower logo"/><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="__className_30b088 antialiased bg-gray-200 overflow-scroll"><div class="w-full"><div class="w-full flex flex-col items-center justify-center bg-gray-50 shadow-lg sm:mb-5 py-5"><div class="ml-[calc(50vw-150px)] sm:ml-0 px-2 flex flex-row items-center"><img alt="cactus flower logo" loading="lazy" width="100" height="97" decoding="async" data-nimg="1" style="color:transparent" src="/cactus_flower_logo.svg"/><h1 class="font-bold uppercase text-3xl pl-6">Maarten van Beek</h1></div><div class="flex w-full min(56rem,100%)] mx-auto justify-center gap-9 pt-2"><a href="/">CV</a><p>/</p><a class="font-black" href="/blog/">Blog</a></div></div><div class="max-w-4xl mx-auto flex flex-col"><div class="w-full bg-gray-50 shadow-lg mt-2 sm:mt-0"><div><img alt="blog header" loading="lazy" width="800" height="200" decoding="async" data-nimg="1" class="w-full object-cover w-full h-48" style="color:transparent" src="https://picsum.photos/seed/thumb1/1600/900"/><div class="p-5"><h3><strong>TLDR;</strong></h3>
<div class="mb-2">In order to experiment with shaders (programs running on the GPU, utilizing its parallel power),
I wrote a shader which renders the cactus flower logo. No premade pictures are used, the entire picture
aswell as the animations are calculated real-time. It utilizes <strong>signed distance functions (SDFs)</strong> as well as the <strong>rotational symmetry</strong> of the logo to achieve the result. In the post below I elaborate on
how it was done. The following is the result, the code is available on <a class="font-bold text-blue-700" href="https://www.shadertoy.com/view/tcSXzW">Shadertoy</a>.
<div class="flex flex-col justify-center items-center mt-3 mb-5"><video class="drop-shadow-sm rounded-xl" width="400" autoPlay="" muted="" loop=""><source src="/cactus_flower_shader_capture.mp4" type="video/mp4"/></video><span>Render of shader for cactus flower logo</span></div></div>
<h1 class="font-bold text-3xl mb-3">Shaders</h1>
<div class="mb-2">A shader is a program which runs on the GPU, commonly to render some visual.
They utilize the GPUs capabalities for running a high number of computations
in parallel. This particular fragment shader is run for each pixel of the visual, outputting the
color it should have for the current frame. After the color has been determined
for each pixel, the frame is rendered and can be shown. Then the process repeats
for the next frame.</div>
<div class="mb-2">These shaders cannot have a dependency on the computations
done for another pixel, as this would break the possibility of them running in parallel.
There is a limited amount of input for each computation. For example, the shader does
know the coordinates of the pixel it is executing for, and it knows the time since it
started running, however, it doesn&#x27;t know the output of a computation done for a different pixel.
These limitations must be taken into account when writing a shader, and techniques must be applied
to achieve the desired result despite these limitations. One such technique, are <strong>SDFs</strong>.</div>
<h1 class="font-bold text-3xl mb-3">SDFs</h1>
<div class="mb-2">Consider a shape you&#x27;d like to draw on your canvas. Say you would like to draw a circle. A
<strong>signed distance function (SDF)</strong> is a mathematical function which describes the shortest
distance to this shape for any point on your canvas. On the border of your shape this distance
will be close to zero, further away from the shape this value will be higher. If the point
is within your shape, the distance will be a negative number. <a class="font-bold text-blue-700" href="https://iquilezles.org/">Inigo Quilez</a>
has some amazing articles on the topic.</div>
<div class="mb-2">These functions are useful, as they can run in parallel for each pixel, independently. Perfect
for computations done on the GPU. We can now run the following shader for each pixel on the visual.
First, we determine the SDF value for the current pixel. If the value is below zero (within the shape)
we color the pixel black. If the value is equal to or above zero, we color the pixel white. Without
any knowledge of any neighbouring pixels we can now know exactly what color we have to color our pixel
in order to render a circle on the screen.</div>
<div class="mb-2">Another favourable characteristic of SDFs, is that they&#x27;re easy to combine. If you compute the SDF
for two shapes, and take the highest value for these two SDFs, you now have an SDF for the space
in which these shapes overlap. This characteristic can be used to assemble more complex shapes from
primitives shapes (such as circles, squares, lines, etc).</div>
<h1 class="font-bold text-3xl mb-3">This particular shader</h1>
<div class="mb-2">The shader as seen above utilizes a few techniques. It uses <strong>SDFs</strong> to construct the design from
primitive shapes.</div>
<div class="mb-2">It uses the fact that the design is the same pattern repeated 6 six times rotationally
to reduce the amount of computations used. This may be called it&#x27;s <strong>rotational symmetry</strong>.
To achieve this, it determines whether a point lies in one of the six rotations, and then
maps this point to the point in the non-rotated segment. It then renders for this pixel whatever
is renders for this point in the non rotated segment.</div>
<div class="mb-2">It <strong>warps the coordinate space</strong> in order to achieve the shockwave/water effect. Within the range
within which the effect is applied, the coordinates of a point are mapped to either a point further towards,
or further away from the origin. This creates a radial distortion at a given distance from the origin.
The distance from the origin is a function of the runtime of the shader, which makes the effect move radially
outward.</div>
<h1 class="font-bold text-3xl mb-3">A more indepth look</h1>
<div class="mb-2">The entire code for this shader can be found on <a class="font-bold text-blue-700" href="https://www.shadertoy.com/view/tcSXzW">Shadertoy</a>.
As reading this code without any prior knowledge can be challenging, I will elaborate on some of the techniques
used in the shader.</div>
<a href="#normalizing_the coordinate space"><h2 class="font-bold mb-2 text-lg hover:underline" id="normalizing_the coordinate space">Normalizing the coordinate space</h2></a>
<div class="mb-2">By default a pixel its coordinates depend on the resolution of the render. <code class="language-glsl">(0,0)</code> lies in the bottom left corner.
The x coordinates will then be an integer <code class="language-glsl">&gt;= 0</code> and <code class="language-glsl">&lt; horizontal_resolution</code>. The y coordinate is the same,
but considering its vertical resolution. It&#x27;s practical for these coordinates to be resolution independent, in order
to render on any given resolution. Therefore the coordinates are mapped to values ranging from <code class="language-glsl">-1</code> to <code class="language-glsl">1</code>, where
<code class="language-glsl">(-1,-1)</code> is the bottom left corner and <code class="language-glsl">(1,1)</code> is the top right corner. This is all achieved by the following code</div>
<pre><code class="language-glsl">#define shortestWidth min(iResolution.x,iResolution.y)

// fragCoord is the (x,y) coordinate of the current pixel relative to the resolution
vec2 uv = (2.*fragCoord-iResolution.xy)/shortestWidth;
</code></pre>
<a href="#achieving_rotational symmetry"><h2 class="font-bold mb-2 text-lg hover:underline" id="achieving_rotational symmetry">Achieving rotational symmetry</h2></a>
<pre><code class="language-glsl">length(uv) * cos((mod(atan(uv.y/uv.x)-PI/3.,PI/3.)+PI/3.)+vec2(0., -0.5*PI));
</code></pre>
<div class="mb-2">This requires some dissecting. If you consider the coordinates of the current pixel a vector from the origin,
<code class="language-glsl">atan(uv.y/uv.x)</code> computes the angle of this vector. We want the segment facing upward to be our default segment,
as in this sector the x and y dimensions are running in their usual direction. Taking the modulo of this angle
makes sure that if we exceed this angle beyond 1/6th of the full rotation, we normalize it back to this initial segment.
The <code class="language-glsl">cos(angle, angle+0.5*PI)</code> converts this angle back to coordinates. We have lost the length information for this
vector, so these coordinates will now always be at exactly distance <code class="language-glsl">1</code> from the origin. Therefore we multiple the
result with <code class="language-glsl">length(uv)</code>, the length of the original vector. The result is that any point will be mapped to
this 1/6th segment of the canvas, pointing upwards. The consequence is that any rendered pixel is repeated 6 times
rotationally.</div>
<a href="#shockwave_/ water effect"><h2 class="font-bold mb-2 text-lg hover:underline" id="shockwave_/ water effect">Shockwave / water effect</h2></a>
<pre><code class="language-glsl">float width = 0.2;
float strength = .2;
float progress = min(max(length(uv)-startVectorLength, 0.), width)/width; 
float deformationFactor = 1. + strength*sin(PI*progress+PI); 
return uv*deformationFactor;
</code></pre>
<div class="mb-2">This is written less compactly, but isn&#x27;t more complex than anything that has come before.
The <code class="language-glsl">width</code> and <code class="language-glsl">strength</code> are constants tune the effect to look good. The <code class="language-glsl">progress</code>
variable takes the distance from the origin to the current point, and determines whether
it lies within the effect by considering the <code class="language-glsl">startVectorLength</code> (distance at which the effect begins)
and the <code class="language-glsl">width</code> (distance that the effect lasts). If it does, it determins the deformation strength.
This strength is small at the start and end distances of the effect, and peaks in the middle.
This strength is then applied to the coordinates of the current pixel, to instead render a pixel
that&#x27;s supposed to be further out or in.</div>
<h1 class="font-bold text-3xl mb-3">Conclusion</h1>
<div class="mb-2">It requires some unusual thinking to get a shader right. Most programs written for a CPU
iterate over the given space, maintaining state as they do.
Writing a shader is like writing a loop in which each iteration is executed instantaniously,
and no state can be maintained. While this might be initially challenging, the results are of
higher performance than an iterative approach would likely be. <a class="font-bold text-blue-700" href="https://www.shadertoy.com">Shadertoy</a>
is full of creative ways people have used shaders to create beautiful visuals. <a class="font-bold text-blue-700" href="https://www.shadertoy.com/view/4ttSWf">This</a>,
<a class="font-bold text-blue-700" href="https://www.shadertoy.com/view/Ms2SD1">this</a> and <a class="font-bold text-blue-700" href="https://www.shadertoy.com/view/tlVGDt">this</a> are great
examples of people using shaders to get great realtime results, give them a look!</div></div></div></div></div></div><script src="/_next/static/chunks/webpack-50947f5c0ca940e8.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[7970,[\"970\",\"static/chunks/970-c92a9d6897ab6f71.js\",\"173\",\"static/chunks/173-0c26dd97dcd696c8.js\",\"831\",\"static/chunks/app/blog/page-e0864ade7711998e.js\"],\"Image\"]\n3:I[9984,[\"970\",\"static/chunks/970-c92a9d6897ab6f71.js\",\"173\",\"static/chunks/173-0c26dd97dcd696c8.js\",\"177\",\"static/chunks/app/layout-bbbc5ec467b780d9.js\"],\"default\"]\n4:I[5244,[],\"\"]\n5:I[3866,[],\"\"]\n7:I[6213,[],\"OutletBoundary\"]\n9:I[6213,[],\"MetadataBoundary\"]\nb:I[6213,[],\"ViewportBoundary\"]\nd:I[4835,[],\"\"]\n:HL[\"/_next/static/media/f686a73ef698d4bc-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/css/409d8ae84a415574.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"HpP9Y1JsV55jHW7ong37A\",\"p\":\"\",\"c\":[\"\",\"blog\",\"0\",\"\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"blog\",{\"children\":[[\"slug\",\"0\",\"d\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/409d8ae84a415574.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[[\"$\",\"head\",null,{}],[\"$\",\"body\",null,{\"className\":\"__className_30b088 antialiased bg-gray-200 overflow-scroll\",\"children\":[\"$\",\"div\",null,{\"className\":\"w-full\",\"children\":[[\"$\",\"div\",null,{\"className\":\"w-full flex flex-col items-center justify-center bg-gray-50 shadow-lg sm:mb-5 py-5\",\"children\":[[\"$\",\"div\",null,{\"className\":\"ml-[calc(50vw-150px)] sm:ml-0 px-2 flex flex-row items-center\",\"children\":[[\"$\",\"$L2\",null,{\"src\":\"/cactus_flower_logo.svg\",\"width\":\"100\",\"height\":\"97\",\"alt\":\"cactus flower logo\"}],[\"$\",\"h1\",null,{\"className\":\"font-bold uppercase text-3xl pl-6\",\"children\":\"Maarten van Beek\"}]]}],[\"$\",\"div\",null,{\"className\":\"flex w-full min(56rem,100%)] mx-auto justify-center gap-9 pt-2\",\"children\":[\"$\",\"$L3\",null,{}]}]]}],[\"$\",\"div\",null,{\"className\":\"max-w-4xl mx-auto flex flex-col\",\"children\":[\"$\",\"$L4\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L5\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[],[\"$\",\"div\",null,{\"className\":\"flex items-center justify-center w-full h-full\",\"children\":[\"$\",\"span\",null,{\"className\":\"text-8xl font-bold text-gray-400 text-center\",\"children\":\"Not found\"}]}]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]]}]}]]}]]}],{\"children\":[\"blog\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L4\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"blog\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L5\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"slug\",\"0\",\"d\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"div\",null,{\"className\":\"w-full bg-gray-50 shadow-lg mt-2 sm:mt-0\",\"children\":[\"$\",\"$L4\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"blog\",\"children\",\"$0:f:0:1:2:children:2:children:0\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L5\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$L6\",null,[\"$\",\"$L7\",null,{\"children\":\"$L8\"}]]}],{},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"8oSx3pdMBi6oADrH-BUxN\",{\"children\":[[\"$\",\"$L9\",null,{\"children\":\"$La\"}],[\"$\",\"$Lb\",null,{\"children\":\"$Lc\"}],[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\",\"content\":\"\"}]]}]]}],false]],\"m\":\"$undefined\",\"G\":[\"$d\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"c:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\na:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"1\",{\"children\":\"Maarten van Beek\"}],[\"$\",\"meta\",\"2\",{\"property\":\"og:title\",\"content\":\"Maarten van Beek\"}],[\"$\",\"meta\",\"3\",{\"property\":\"og:description\",\"content\":\"Software developer\"}],[\"$\",\"meta\",\"4\",{\"property\":\"og:site_name\",\"content\":\"Maarten van Beek\"}],[\"$\",\"meta\",\"5\",{\"property\":\"og:image\",\"content\":\"https://www.maartenvb.org/cactus_flower_logo.png\"}],[\"$\",\"meta\",\"6\",{\"property\":\"og:image:secure_url\",\"content\":\"http://www.maartenvb.org/cactus_flower_logo.png\"}],[\"$\",\"meta\",\"7\",{\"property\":\"og:image:width\",\"content\":\"1600\"}],[\"$\",\"meta\",\"8\",{\"property\":\"og:image:height\",\"content\":\"900\"}],[\"$\",\"meta\",\"9\",{\"property\":\"og:image:alt\",\"content\":\"cactus flower logo\"}],[\"$\",\"meta\",\"10\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"11\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"12\",{\"name\":\"twitter:title\",\"content\":\"Maarten van Beek\"}],[\"$\",\"meta\",\"13\",{\"name\":\"twitter:description\",\"content\":\"Software developer\"}],[\"$\",\"meta\",\"14\",{\"name\":\"twitter:image\",\"content\":\"https://www.maartenvb.org/cactus_flower_logo.png\"}],[\"$\",\"meta\",\"15\",{\"name\":\"twitter:image:secure_url\",\"content\":\"http://www.maartenvb.org/cactus_flower_logo.png\"}],[\"$\",\"meta\",\"16\",{\"name\":\"twitter:image:width\",\"content\":\"1600\"}],[\"$\",\"meta\",\"17\",{\"name\":\"twitter:image:height\",\"content\":\"900\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:image:alt\",\"content\":\"cactus flower logo\"}]]\n"])</script><script>self.__next_f.push([1,"8:null\n"])</script><script>self.__next_f.push([1,"e:I[5425,[\"970\",\"static/chunks/970-c92a9d6897ab6f71.js\",\"173\",\"static/chunks/173-0c26dd97dcd696c8.js\",\"953\",\"static/chunks/app/blog/%5Bslug%5D/page-3b3d82faeb35df04.js\"],\"default\"]\nf:T3156,"])</script><script>self.__next_f.push([1,"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    code: \"code\",\n    h1: \"h1\",\n    h2: \"h2\",\n    h3: \"h3\",\n    p: \"p\",\n    pre: \"pre\",\n    strong: \"strong\",\n    ..._provideComponents(),\n    ...props.components\n  }, {Figure, Video} = _components;\n  if (!Figure) _missingMdxReference(\"Figure\", true);\n  if (!Video) _missingMdxReference(\"Video\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h3, {\n      children: _jsx(_components.strong, {\n        children: \"TLDR;\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"In order to experiment with shaders (programs running on the GPU, utilizing its parallel power),\\nI wrote a shader which renders the cactus flower logo. No premade pictures are used, the entire picture\\naswell as the animations are calculated real-time. It utilizes \", _jsx(_components.strong, {\n        children: \"signed distance functions (SDFs)\"\n      }), \" as well as the \", _jsx(_components.strong, {\n        children: \"rotational symmetry\"\n      }), \" of the logo to achieve the result. In the post below I elaborate on\\nhow it was done. The following is the result, the code is available on \", _jsx(_components.a, {\n        href: \"https://www.shadertoy.com/view/tcSXzW\",\n        children: \"Shadertoy\"\n      }), \".\\n\", _jsxs(Figure, {\n        children: [_jsx(Video, {\n          source: \"/cactus_flower_shader_capture.mp4\"\n        }), _jsx(\"span\", {\n          children: \"Render of shader for cactus flower logo\"\n        })]\n      })]\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"Shaders\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"A shader is a program which runs on the GPU, commonly to render some visual.\\nThey utilize the GPUs capabalities for running a high number of computations\\nin parallel. This particular fragment shader is run for each pixel of the visual, outputting the\\ncolor it should have for the current frame. After the color has been determined\\nfor each pixel, the frame is rendered and can be shown. Then the process repeats\\nfor the next frame.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"These shaders cannot have a dependency on the computations\\ndone for another pixel, as this would break the possibility of them running in parallel.\\nThere is a limited amount of input for each computation. For example, the shader does\\nknow the coordinates of the pixel it is executing for, and it knows the time since it\\nstarted running, however, it doesn't know the output of a computation done for a different pixel.\\nThese limitations must be taken into account when writing a shader, and techniques must be applied\\nto achieve the desired result despite these limitations. One such technique, are \", _jsx(_components.strong, {\n        children: \"SDFs\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"SDFs\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Consider a shape you'd like to draw on your canvas. Say you would like to draw a circle. A\\n\", _jsx(_components.strong, {\n        children: \"signed distance function (SDF)\"\n      }), \" is a mathematical function which describes the shortest\\ndistance to this shape for any point on your canvas. On the border of your shape this distance\\nwill be close to zero, further away from the shape this value will be higher. If the point\\nis within your shape, the distance will be a negative number. \", _jsx(_components.a, {\n        href: \"https://iquilezles.org/\",\n        children: \"Inigo Quilez\"\n      }), \"\\nhas some amazing articles on the topic.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"These functions are useful, as they can run in parallel for each pixel, independently. Perfect\\nfor computations done on the GPU. We can now run the following shader for each pixel on the visual.\\nFirst, we determine the SDF value for the current pixel. If the value is below zero (within the shape)\\nwe color the pixel black. If the value is equal to or above zero, we color the pixel white. Without\\nany knowledge of any neighbouring pixels we can now know exactly what color we have to color our pixel\\nin order to render a circle on the screen.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Another favourable characteristic of SDFs, is that they're easy to combine. If you compute the SDF\\nfor two shapes, and take the highest value for these two SDFs, you now have an SDF for the space\\nin which these shapes overlap. This characteristic can be used to assemble more complex shapes from\\nprimitives shapes (such as circles, squares, lines, etc).\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"This particular shader\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The shader as seen above utilizes a few techniques. It uses \", _jsx(_components.strong, {\n        children: \"SDFs\"\n      }), \" to construct the design from\\nprimitive shapes.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"It uses the fact that the design is the same pattern repeated 6 six times rotationally\\nto reduce the amount of computations used. This may be called it's \", _jsx(_components.strong, {\n        children: \"rotational symmetry\"\n      }), \".\\nTo achieve this, it determines whether a point lies in one of the six rotations, and then\\nmaps this point to the point in the non-rotated segment. It then renders for this pixel whatever\\nis renders for this point in the non rotated segment.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"It \", _jsx(_components.strong, {\n        children: \"warps the coordinate space\"\n      }), \" in order to achieve the shockwave/water effect. Within the range\\nwithin which the effect is applied, the coordinates of a point are mapped to either a point further towards,\\nor further away from the origin. This creates a radial distortion at a given distance from the origin.\\nThe distance from the origin is a function of the runtime of the shader, which makes the effect move radially\\noutward.\"]\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"A more indepth look\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The entire code for this shader can be found on \", _jsx(_components.a, {\n        href: \"https://www.shadertoy.com/view/tcSXzW\",\n        children: \"Shadertoy\"\n      }), \".\\nAs reading this code without any prior knowledge can be challenging, I will elaborate on some of the techniques\\nused in the shader.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Normalizing the coordinate space\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"By default a pixel its coordinates depend on the resolution of the render. \", _jsx(_components.code, {\n        children: \"(0,0)\"\n      }), \" lies in the bottom left corner.\\nThe x coordinates will then be an integer \", _jsx(_components.code, {\n        children: \"\u003e= 0\"\n      }), \" and \", _jsx(_components.code, {\n        children: \"\u003c horizontal_resolution\"\n      }), \". The y coordinate is the same,\\nbut considering its vertical resolution. It's practical for these coordinates to be resolution independent, in order\\nto render on any given resolution. Therefore the coordinates are mapped to values ranging from \", _jsx(_components.code, {\n        children: \"-1\"\n      }), \" to \", _jsx(_components.code, {\n        children: \"1\"\n      }), \", where\\n\", _jsx(_components.code, {\n        children: \"(-1,-1)\"\n      }), \" is the bottom left corner and \", _jsx(_components.code, {\n        children: \"(1,1)\"\n      }), \" is the top right corner. This is all achieved by the following code\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"#define shortestWidth min(iResolution.x,iResolution.y)\\n\\n// fragCoord is the (x,y) coordinate of the current pixel relative to the resolution\\nvec2 uv = (2.*fragCoord-iResolution.xy)/shortestWidth;\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Achieving rotational symmetry\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"length(uv) * cos((mod(atan(uv.y/uv.x)-PI/3.,PI/3.)+PI/3.)+vec2(0., -0.5*PI));\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"This requires some dissecting. If you consider the coordinates of the current pixel a vector from the origin,\\n\", _jsx(_components.code, {\n        children: \"atan(uv.y/uv.x)\"\n      }), \" computes the angle of this vector. We want the segment facing upward to be our default segment,\\nas in this sector the x and y dimensions are running in their usual direction. Taking the modulo of this angle\\nmakes sure that if we exceed this angle beyond 1/6th of the full rotation, we normalize it back to this initial segment.\\nThe \", _jsx(_components.code, {\n        children: \"cos(angle, angle+0.5*PI)\"\n      }), \" converts this angle back to coordinates. We have lost the length information for this\\nvector, so these coordinates will now always be at exactly distance \", _jsx(_components.code, {\n        children: \"1\"\n      }), \" from the origin. Therefore we multiple the\\nresult with \", _jsx(_components.code, {\n        children: \"length(uv)\"\n      }), \", the length of the original vector. The result is that any point will be mapped to\\nthis 1/6th segment of the canvas, pointing upwards. The consequence is that any rendered pixel is repeated 6 times\\nrotationally.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Shockwave / water effect\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"float width = 0.2;\\nfloat strength = .2;\\nfloat progress = min(max(length(uv)-startVectorLength, 0.), width)/width; \\nfloat deformationFactor = 1. + strength*sin(PI*progress+PI); \\nreturn uv*deformationFactor;\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"This is written less compactly, but isn't more complex than anything that has come before.\\nThe \", _jsx(_components.code, {\n        children: \"width\"\n      }), \" and \", _jsx(_components.code, {\n        children: \"strength\"\n      }), \" are constants tune the effect to look good. The \", _jsx(_components.code, {\n        children: \"progress\"\n      }), \"\\nvariable takes the distance from the origin to the current point, and determines whether\\nit lies within the effect by considering the \", _jsx(_components.code, {\n        children: \"startVectorLength\"\n      }), \" (distance at which the effect begins)\\nand the \", _jsx(_components.code, {\n        children: \"width\"\n      }), \" (distance that the effect lasts). If it does, it determins the deformation strength.\\nThis strength is small at the start and end distances of the effect, and peaks in the middle.\\nThis strength is then applied to the coordinates of the current pixel, to instead render a pixel\\nthat's supposed to be further out or in.\"]\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"Conclusion\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"It requires some unusual thinking to get a shader right. Most programs written for a CPU\\niterate over the given space, maintaining state as they do.\\nWriting a shader is like writing a loop in which each iteration is executed instantaniously,\\nand no state can be maintained. While this might be initially challenging, the results are of\\nhigher performance than an iterative approach would likely be. \", _jsx(_components.a, {\n        href: \"https://www.shadertoy.com\",\n        children: \"Shadertoy\"\n      }), \"\\nis full of creative ways people have used shaders to create beautiful visuals. \", _jsx(_components.a, {\n        href: \"https://www.shadertoy.com/view/4ttSWf\",\n        children: \"This\"\n      }), \",\\n\", _jsx(_components.a, {\n        href: \"https://www.shadertoy.com/view/Ms2SD1\",\n        children: \"this\"\n      }), \" and \", _jsx(_components.a, {\n        href: \"https://www.shadertoy.com/view/tlVGDt\",\n        children: \"this\"\n      }), \" are great\\nexamples of people using shaders to get great realtime results, give them a look!\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n"])</script><script>self.__next_f.push([1,"6:[\"$\",\"$Le\",null,{\"compiledSource\":\"$f\",\"frontmatter\":{\"title\":\"Cactus flower shader\",\"thumb\":\"/cactus_flower_shader_thumb.jpg\",\"summary\":\"A shader for the cactus flower logo, using SDFs\",\"image\":\"https://picsum.photos/seed/thumb1/1600/900\"},\"scope\":{},\"image\":\"https://picsum.photos/seed/thumb1/1600/900\"}]\n"])</script></body></html>